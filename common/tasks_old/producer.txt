import os
import json
import logging
import aio_pika
import asyncio
from fastapi import APIRouter, FastAPI, HTTPException
from pydantic import BaseModel, EmailStr
from typing import Dict
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from contextlib import asynccontextmanager
from user_code import TableData, TablePredictions, AsPredictModel as PredictModel
from sqlalchemy.future import select as sql_select
from db.config_db import get_settings

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

task_route = APIRouter()

RABBITMQ_USER = os.getenv('RABBITMQ_USER', 'user')
RABBITMQ_PASS = os.getenv('RABBITMQ_PASS', 'password')
DATABASE_URL = os.getenv('DATABASE_URL')

engine = create_async_engine(get_settings().DATABASE_URL_psycopg, echo=True, pool_size=5, max_overflow=10)
async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

class DataTask(BaseModel):
    email: EmailStr
    user_id: int
    data: Dict[str, float]

class PredictionTask(BaseModel):
    email: EmailStr
    user_id: int
    data_id: int

@asynccontextmanager
async def get_db_session():
    session = async_session()
    try:
        yield session
        await session.commit()
    except Exception as e:
        await session.rollback()
        logger.error("Session rollback due to exception: %s", e)
        raise
    finally:
        await session.close()


async def send_to_queue(queue_name: str, task: dict):
    connection = await aio_pika.connect_robust(f"amqp://{RABBITMQ_USER}:{RABBITMQ_PASS}@rabbitmq/")
    async with connection:
        channel = await connection.channel()
        await channel.default_exchange.publish(
            aio_pika.Message(
                body=json.dumps(task).encode()
            ),
            routing_key=queue_name
        )

@task_route.post("/load_data/")
async def load_data(task: DataTask):
    async with get_db_session() as session:
        try:
            new_data = TableData(email=task.email, user_id=task.user_id, data=task.data)
            session.add(new_data)
            await session.commit()
            logger.debug(f"Data processed for user {task.email} with data id {new_data.data_id}")
            
            return {"status": "success", "data_id": new_data.data_id}
        except Exception as e:
            logger.error(f"Error processing task: {e}")
            raise HTTPException(status_code=500, detail="Internal Server Error")

@task_route.post("/predict/")
async def predict(task: PredictionTask):
    async with get_db_session() as session:
        try:
            data_id = task.data_id
            email = task.email
            user_id = task.user_id

            predictor = PredictModel(model={}, session=session, email=email, user_id=user_id)
            predictor._data_id = data_id
            prediction = await predictor.predict()  
            new_prediction = TablePredictions(
                email=email,
                user_id=user_id,
                data_id=data_id,
                prediction=prediction
            )
            session.add(new_prediction)
            await session.commit()
            logger.debug(f"Prediction result for user {email} published with data id {data_id}")

            return {"status": "success", "prediction": prediction}
        except Exception as e:
            logger.error(f"Error processing prediction: {e}")
            raise HTTPException(status_code=500, detail="Internal Server Error")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
